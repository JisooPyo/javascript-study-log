/**
 * ============================================================
 * 상태 관리(State Management)
 * ============================================================
 *
 * [왜 상태를 알아야 하나?]
 * - 컴포넌트 단위로 나눈 여러 파일(컴포넌트)들을 app.js 같은 하나의 상위 컴포넌트에서 관리하려면 "상태(state)" 개념을 이해해야 한다.
 *
 * ------------------------------------------------------------
 * state(상태)란?
 * ------------------------------------------------------------
 * - 웹페이지 내에서 "변화하는 데이터" 전체를 의미한다.
 * - 눈에 보이는 변화(화면에 표시되는 값)뿐 아니라 눈에 보이지 않는 변화(내부 데이터)도 포함한다.
 *
 * 예시
 * - 사용자가 입력한 값(input)
 * - 체크박스 체크 여부
 * - 버튼 클릭 상태(어떤 버튼을 눌렀는지)
 * - 사용자 정보
 * - 게시글 목록
 * - API 호출 결과 데이터
 *
 * 우리가 만들고 있는 웹페이지에서는 예를 들어
 * - "어떤 버튼을 눌렀는지에 대한 데이터"
 * - "API 호출의 결과값(예: 사진 데이터 등)"
 * 같은 것들을 상태로 표현할 수 있다.
 *
 * ------------------------------------------------------------
 * 상태 관리가 중요한 이유
 * ------------------------------------------------------------
 * - 상태는 화면(보이는 영역) 또는 내부 로직(보이지 않는 영역)에서 실시간으로 변할 수 있다.
 * - 따라서 "상태가 언제, 어떤 값으로 바뀌었는지"를 관리하는 것이 중요하다.
 * - 이러한 상태를 효율적으로 관리하는 방법을 "상태 관리"라고 한다.
 *
 * ------------------------------------------------------------
 * 상태 관리(State Management)란?
 * ------------------------------------------------------------
 * - 웹페이지의 데이터 흐름을 편리하게 관리한다.
 * - 상태를 효율적으로 변경한다.
 * - 불필요한 리렌더링이 발생하지 않게 하여 사용자에게 더 좋은 경험을 제공한다.
 *
 * ------------------------------------------------------------
 * 예: 처음에 개발했던 웹페이지의 문제점
 * ------------------------------------------------------------
 * - 펭귄 버튼을 누르면 penguin.html을 불러오고 페이지의 모든 요소를 다시 렌더링했다.
 * - 이 과정에서 페이지 로딩 시간이 늘어나 사용자 경험이 좋아지지 못했다.
 *
 * ------------------------------------------------------------
 * 컴포넌트 + 상태 관리로 개선되는 점
 * ------------------------------------------------------------
 * - 페이지를 컴포넌트 단위로 나눈 뒤, 상태를 기준으로 렌더링하면 "변화가 필요한 부분만" 렌더링한다.
 * - 즉, 불필요한 리렌더링이 발생하지 않는다.
 *
 * ------------------------------------------------------------
 * 컴포넌트 간 상호작용과 상태 관리
 * ------------------------------------------------------------
 * - 컴포넌트들이 올바르게 동작하려면 서로 데이터를 공유하며 상호작용해야 한다.
 *
 * 만약 데이터가 바뀔 때마다
 * - 전체 페이지를 매번 다시 렌더링하거나
 * - DOM을 하나하나 찾아 직접 바꾸는 방식으로 처리하면 중복 코드가 많아지고 DOM 접근 횟수도 불필요하게 늘어난다.
 *
 * 상태 관리는 이러한 문제를 해결하기 위해 등장했다.
 *
 * ------------------------------------------------------------
 * 상태 관리가 주는 효과(정리)
 * ------------------------------------------------------------
 * - 데이터 흐름을 효율적으로 관리한다.
 * - 변경이 발생한 상태만 업데이트할 수 있다.
 * - 기존 방식에 비해 성능을 향상시키고 데이터 관리를 더 쉽게 만든다.
 * - 불필요한 리렌더링을 방지하여 웹 애플리케이션 성능을 최적화할 수 있다.
 *
 * ------------------------------------------------------------
 * 상태 관리는 프레임워크/라이브러리에서도 중요하다
 * ------------------------------------------------------------
 * - 상태 관리는 바닐라 자바스크립트 뿐 아니라 라이브러리 및 프레임워크에서도 사용되는 중요한 개념이다.
 *
 * - React.js에서는 Hook을 사용하거나, Redux 같은 별도의 라이브러리를 사용해 상태를 더욱 효율적으로 관리한다.
 *
 * - 따라서 상태 관리 개념을 잘 익혀두면 React를 포함한 다양한 프론트엔드 도구에서 더 깊이 있고 효과적으로 활용할 수 있다.
 */

/**
 * ============================================================
 * 실제 파일 내부에서 상태를 관리하는 일반적인 구조
 * ============================================================
 *
 * [목표]
 * - 여러 상태들을 한 곳에서 관리한다.
 * - 상태 변화가 일어나면 UI를 업데이트한다.
 *
 * [가장 일반적인 구조]
 * - state: 현재 상태 저장
 * - setState(nextState): 상태 변경 + 렌더링 트리거
 * - render(): 상태를 기반으로 UI를 다시 그리는 함수
 *
 * 이 구조는 React의 state / setState / render 방식과 비슷하다.
 *
 * ------------------------------------------------------------
 * React와의 차이점
 * ------------------------------------------------------------
 * - React에는 state 관리 및 렌더링 관련 기능이 내장되어 있다.
 * - 하지만 바닐라 자바스크립트에는 이런 기능이 내장되어 있지 않다.
 * - 따라서 비슷한 동작을 하게 하려면 직접 구현해야 한다.
 *
 * 아래는 형태를 이해하기 위한 "구조 예시"이다.
 */

// this.state = {
//   // 초기 상태 값들
// };

// this.setState = (nextState) => {
//   this.state = nextState;
//   // 상태 업데이트 후 렌더링
//   this.render();
// };

// this.render = () => {
//   // UI 렌더링 로직
// };
